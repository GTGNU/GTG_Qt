// ROBADOB
//This is a hypothetical psuedo-c class hierarchy to use for storing and accessing the environment/map
EnvLoader
{
    Area areas[];
    MapResources mr; 
    bool serialise();   //Protocol buffer, serialise method
    bool deserialise(); //Protocol buffer, deserialise method
    bool toXML();       //xcv_'s xml/js interface
    bool fromXML();     //xcv_'s xml/js interface
}
EnvResources
{//This static class acts as a loader and manager of resources to prevent wasting memory by double loading the same resource
//Undecided on whether to use the resources path as its key to the hashmap, or to store loaded resource paths in a seperate map and return an integer key on load (this would further reduce multiple objects holding possible long paths)
//A further possiblity would be the use of smart pointers managed by this class
    public:
        static bool loadAudio(QString path);//Checks the audio isn't already loaded and adds to propertyAudio
        static bool loadGraphic(QString path);//Checks the graphic isn't already loaded and adds to tileGraphics
        static ?Audio getAudio(QString path);//Getter for loaded resources
        static ?Image getGraphic(QString path);//Getter for loaded resources
    private:
        static  QVarLengthArray<Tile>  tiles;
        static  QHash<QString, ?Image> tileGraphics;
        static  QHash<QString, ?Audio> propertyAudio;
}
Area
{//Need to decide the preferred method for accessing tiles for render etc.
    int tiles[][];          //index to MapResources.tiles, allows us to repeat usage of tiles

    Tile getTile(int x, int y);//Return individual tile
    Tile[][] getTiles(int x1, int y1);
}
Tile
{
    QString graphics;             //index to MapResources.tileGraphics
    QVarLengthArray<TileProperty> properties;//Holds all tile properties, instanced, properties executed in order they are added to the array, use a 'delay' property if you want multiple things with delays
    
}
TileProperty//Features e.g. portals, powerups, environment sounds etc
{//In theory this should be a fairly complete abstract for tile properties, although its clearly missing the serial methods and would need to be split into .h and .cpp
    private :
        const int DEFAULT_HEAP_SIZE = 0;
	public :
        TileProperty()
        {
            QVarLengthArray<PropertyFilter> filters(DEFAULT_HEAP_SIZE);
        }
        bool pass()
        {//Checks whether all filters can be passed
            for (int i = 0; i < filters.size(); ++i)
                if(!filters[i].pass())
                    return false;
            return true;
        }
        bool execute()
        {//If pass succeeds, calls runEffect
            if(pass())
                return runEffect();
            return false;
        }
    protected :
        void addFilter(PropertyFilter pf)
        {//This should be called by the subclasses constructor to add filters
            filters.append(pf);
        }
        virtual boolean runEffect() = 0;//This should be called by the subclass to execute the properties effect
        QVarLengthArray<PropertyFilter> filters;//Holds all filters, instanced
}
PropertyFilter
{
    virtual boolean pass() = 0;//Returns true if the filter passes (true cont, false exit)
}

//this enables us to create properties such as
EnvSoundProperty : public TileProperty
{
    private :
        QString envSound;
	public :
        EnvSoundProperty(QString path)
        {//Preloads the audio and sets the filters
            envSound=path;
            MapResources.loadAudio(path);
            addFilter(AudioNotAlreadyPlayingFilter());
            addFilter(StallmanStandingOnTileFilter());
        }
        void runEffect()
        {//Plays the audio, it might be better for MapResources to play the audio so that it can be used as a global tracker for whether audio is playing or not for the above 'AudioNotAlreadyPlayingFilter'
            ?QPlayer.play(MapResources.getAudio(envSound));
        }
}




// XCV_

- EnvLoader
	- Loads tiles somehow specified in QML
		- Default sound specified in each tile
		- C++ doesn't care about animations
		- Event handling through signal/slot system

	- Loads the map into a matrix of tile keys

- GameController
	- Handles screen switching (menu / conversation / game / loading...)
		- GameScene (QGraphicsView)
			- Builds the map into an actual visual representation on screen
			  using QGraphicsScene and instantiating the map as specified

			- Players' and bots' actions. Where do they belong, C++ or JavaScript?

		- Menu (QQtQuickView or similar)
			- Choice sent through a signal

		- Conversation (QQtQuickView or similar)
			- Fully in QML and JavaScript to allow for easy animations
			  and eye candy

              
//firecheese's opinion on implementation of tile storage
GTGTile
    int index - tile index the maps use
    array of images, each image:
        string - filename
        unsigned int duration - duration in miliseconds (0 = infinite)
        unsigned int x1 - x coordinate of the start of the image
        unsigned int y1 - y coordinate of the start of the image
        unsigned int x2 - x coordinate of the end of the image
        unsigned int y2 - y coordinate of the end of the image
        
GTGMap
    int tileIndexes[][]
    bool isSolid[][]
    
GTGPlayer
    int x,y
    int tileIndexLeft, tileIndexRight, ...
    
GTG
    GTGMap map
    GTGPlayer player

//baldwin(irc name, idk who he his on git)
Use an mvc architecture to attatch properties to the world, it will remove inefficiency of detecting activation
<baldwin> Look, I'm not sure how useful it'll be - It's basically an example taken from a much more complex and detailed engine plan.
<baldwin> but that engine relies on garbage collection, as it uses a lot of functional programming.
/**
 * Represents a generic component which can be added to game objects at runtime.
 *
 *
 *
 */
interface Component {
 
 
        /**
         * @return a deep copy of this component.
         */
        Component copy();
 
        /**
         * @return a unique identifier associated with this component.
         */
        String getIdentifier();
 
}
 
/**
 * Skeleton example of a specialized component interface. Implementations of this can differ.
 */
interface Drawable : Component {
 
        /**
         * performs the actual drawing of this component.
         * @param draw the render object to make calls to draw with.
         */
        void draw(Drawer draw);
}
 
/**
 * The basic game object. Provides a store for components.
 */
class GameObject {
 
        Map<component, string> componentMap;
 
        /**
         * Returns the component matching the identifier in this object.
         *
         * Only one component can ever exist for a given identifier on a game object.
         */
        Component getComponent(String identifier) {
                return componentMap.get(identifier);
        }
}
 
/**
 * Skeleton example class of something using a component.
 */
class DrawingManager {
 
        Drawer drawer;
 
        const String IDENTIFIER = "DRAWING";
 
        /**
         * Performs the drawing of all game objects that can be drawn.
         *
         *
         */
        draw(List<GameObject> gameobjects) {
                foreach gameobject in gameobjects {
                        Drawable drawable = gameObjects.get(this.identifier);
                        if (drawable != NULL) {
                                drawable.draw(this.drawer);
                        }
                }
        }
}